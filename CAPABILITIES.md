## CloudFlow AWS Capabilities

This document describes:
- Available services in the IR
- Valid connections between services and the required intent keywords
- Example payloads for common patterns
- Backend API endpoints for compile/deploy/destroy/status

### Available services (kinds)
- aws.s3
- aws.sqs
- aws.lambda
- aws.sns
- aws.events.rule
- aws.apigw
- aws.dynamodb
- aws.sfn
- aws.kinesis (optional; not required if your account doesn’t support it)
- aws.pipes (adapter present; connection rules not enabled yet)

### Intents (verbs) and valid connections

- S3
  - notify -> SQS
  - notify -> Lambda
  - notify -> SNS
  - notify -> EventBridge Rule
  - Notes: For EventBridge Rule, we attach a pattern that filters for the source S3 bucket’s object-created events.

- SNS
  - notify | deliver -> Lambda
  - notify | deliver -> SQS

- SQS
  - consume -> Lambda (batchSize supported on the edge)

- EventBridge Rule
  - notify -> Lambda

- API Gateway (REST)
  - invoke -> Lambda (edge supports fields: path, method; method defaults to ANY)

- DynamoDB
  - consume -> Lambda (via Streams; enable table stream in node props)
  - read   <- Lambda (Lambda to DynamoDB grants read; use intent=read)
  - write  <- Lambda (Lambda to DynamoDB grants write; use intent=write)

- Step Functions (State Machine)
  - invoke <- Lambda (Lambda allowed to StartExecution on the State Machine)

- Kinesis (optional)
  - consume -> Lambda (batchSize supported on the edge)

- Pipes (planned)
  - The adapter is present, but engine rules are not enabled yet. If needed, we can enable Pipes to connect sources (e.g., SQS, Kinesis, DynamoDB Streams) to targets (Lambda, SQS, SNS) with filtering and transformations.


### Node property notes
- aws.lambda
  - props.runtime: "python3.12" | "python3.11" | "python3.10" (default: python3.12)
  - props.handler: module.function (default: "app.lambda_handler")
  - props.codeUri: path to function code directory (default: "src/processor")
  - props.memory: number (default: 256)
  - props.timeout: seconds (default: 30)
  - props.physicalName: optional; if omitted, CDK autogenerates a name

- aws.s3
  - props.versioning: boolean (default: true)
  - props.eventBridge: boolean (default: false)
  - props.physicalName: optional; if omitted, CDK autogenerates a name (recommended to avoid global name collisions)

- aws.sqs
  - props.visibilityTimeout: seconds (default: 60)
  - props.dlq: optional object { maxReceiveCount: 5 }
  - props.physicalName: optional; omit for autogenerated

- aws.sns
  - props.displayName: optional
  - props.physicalName: optional

- aws.events.rule
  - props.pattern: EventBridge event pattern (keys like source, detail-type, detail, etc.)

- aws.apigw
  - props.apiName: optional API name; else uses node name

- aws.dynamodb
  - props.partitionKey: string (default "pk")
  - props.sortKey: optional string
  - props.billing: "PAY_PER_REQUEST" | "PROVISIONED" (default "PAY_PER_REQUEST")
  - props.stream: boolean (default true; required for consume -> Lambda)
  - props.physicalName: optional

- aws.sfn
  - props.physicalName: optional; a simple Pass state is created by default

- aws.kinesis (optional)
  - props.shards: number (default 1) OR use streamMode=ON_DEMAND if added later
  - props.physicalName: optional


### Edge property notes
- Common:
  - intent: one of notify | consume | invoke | read | write | deliver
  - batchSize: optional (used by SQS/DynamoDB Streams/Kinesis -> Lambda)

- API Gateway -> Lambda
  - path: "/your/path" (default "/")
  - method: "GET" | "POST" | "PUT" | "DELETE" | "ANY" (default "ANY")


### Example payloads

1) API Gateway -> Lambda (invoke)

```json
{
  "project": "canvas-project",
  "env": "dev",
  "region": "ap-southeast-2",
  "nodes": [
    { "id": "apigw-1", "kind": "aws.apigw", "name": "api" },
    {
      "id": "lambda-api",
      "kind": "aws.lambda",
      "name": "lambda-api",
      "props": { "runtime": "python3.12", "handler": "app.lambda_handler", "codeUri": "src/processor" }
    }
  ],
  "edges": [
    { "from": "apigw-1", "to": "lambda-api", "intent": "invoke", "path": "/hello", "method": "GET" }
  ]
}
```

2) S3 -> SQS (notify), SQS -> Lambda (consume)

```json
{
  "project": "canvas-project",
  "env": "dev",
  "region": "ap-southeast-2",
  "nodes": [
    { "id": "s3-1", "kind": "aws.s3", "name": "ingest-bucket", "props": { "versioning": true } },
    { "id": "sqs-1", "kind": "aws.sqs", "name": "ingest-queue" },
    {
      "id": "lambda-worker",
      "kind": "aws.lambda",
      "name": "lambda-worker",
      "props": { "runtime": "python3.12", "handler": "app.lambda_handler", "codeUri": "src/processor" }
    }
  ],
  "edges": [
    { "from": "s3-1", "to": "sqs-1", "intent": "notify" },
    { "from": "sqs-1", "to": "lambda-worker", "intent": "consume", "batchSize": 10 }
  ]
}
```

3) Lambda <-> DynamoDB (read/write grants) and DynamoDB Streams -> Lambda (consume)

```json
{
  "project": "canvas-project",
  "env": "dev",
  "region": "ap-southeast-2",
  "nodes": [
    {
      "id": "ddb-1",
      "kind": "aws.dynamodb",
      "name": "items-table",
      "props": { "partitionKey": "pk", "sortKey": "sk", "stream": true }
    },
    {
      "id": "lambda-ddb",
      "kind": "aws.lambda",
      "name": "lambda-ddb",
      "props": { "runtime": "python3.12", "handler": "app.lambda_handler", "codeUri": "src/processor" }
    }
  ],
  "edges": [
    { "from": "lambda-ddb", "to": "ddb-1", "intent": "write" },
    { "from": "lambda-ddb", "to": "ddb-1", "intent": "read" },
    { "from": "ddb-1", "to": "lambda-ddb", "intent": "consume", "batchSize": 100 }
  ]
}
```

4) Lambda -> Step Functions (invoke), EventBridge Rule -> Lambda (notify)

```json
{
  "project": "canvas-project",
  "env": "dev",
  "region": "ap-southeast-2",
  "nodes": [
    { "id": "sfn-1", "kind": "aws.sfn", "name": "orchestrator" },
    {
      "id": "lambda-api",
      "kind": "aws.lambda",
      "name": "lambda-api",
      "props": { "runtime": "python3.12", "handler": "app.lambda_handler", "codeUri": "src/processor" }
    },
    {
      "id": "events-rule-1",
      "kind": "aws.events.rule",
      "name": "hourly-trigger",
      "props": { "pattern": { "source": ["custom.app"], "detail-type": ["scheduled"] } }
    },
    {
      "id": "lambda-events",
      "kind": "aws.lambda",
      "name": "lambda-events",
      "props": { "runtime": "python3.12", "handler": "app.lambda_handler", "codeUri": "src/processor" }
    }
  ],
  "edges": [
    { "from": "lambda-api", "to": "sfn-1", "intent": "invoke" },
    { "from": "events-rule-1", "to": "lambda-events", "intent": "notify" }
  ]
}
```


### Backend API endpoints

- POST /aws/compile
  - Body: the IR JSON (as shown above).
  - Action: writes IR to .cdk_build/ir.json and runs “cdk synth” (no AWS changes).

- POST /aws/deploy
  - Body: the IR JSON (same as compile).
  - Action: writes IR, then runs “cdk deploy --require-approval never” (provisions/updates AWS).

- POST /aws/destroy
  - Body: none.
  - Action: runs “cdk destroy --force” for stacks produced by the last compiled IR.

- GET /aws/status
  - Body: none.
  - Action: lists CDK stacks (“cdk list”).


### Notes and tips
- Ensure your Lambda code exists at props.codeUri with the correct handler (e.g., src/processor/app.py exporting lambda_handler).
- Avoid setting global physical names unless necessary; CDK autogenerated names reduce collision risk (e.g., S3 bucket names).
- For SQS/DynamoDB Streams consumes, you can tune batchSize on the edge.


